[
  {
    "title": "Setup: Project Structure and Base Configuration",
    "body": "## Overview\nInitialize the project structure with proper package organization and base configuration files.\n\n## Tasks\n- [ ] Create package structure: `config`, `core`, `domain`, `web`, `worker`, `storage`\n- [ ] Setup application.yml with dev profile configuration\n- [ ] Configure Quarkus extensions for REST, Qute, Hazelcast, etc.\n- [ ] Add logging configuration (text for dev, json for prod)\n- [ ] Create basic health check endpoints\n- [ ] Setup project README with architecture overview\n\n## Acceptance Criteria\n- Project builds successfully with `./mvnw clean package`\n- Health endpoints accessible at `/q/health/live` and `/q/health/ready`\n- Application starts in dev mode with `./mvnw quarkus:dev`\n\n## Labels\nsetup, priority:high, phase:foundation",
    "labels": ["setup", "priority:high", "phase:foundation"],
    "status": "complete"
  },
  {
    "title": "Core: YAML Schema Definitions and Parser",
    "body": "## Overview\nImplement YAML schema definitions for tasks and graphs with validation.\n\n## Tasks\n- [ ] Create `Task` record with all properties (name, command, args, env, timeout, retry, global, key, params)\n- [ ] Create `Graph` record with all properties (name, description, params, env, schedule, tasks)\n- [ ] Create `Parameter` record with type, default, required, description\n- [ ] Implement YAML parser using SnakeYAML\n- [ ] Implement schema validator with proper error messages\n- [ ] Add validation for:\n  - Task name pattern: `^[a-z0-9-]+$`\n  - Graph name pattern: `^[a-z0-9-]+$`\n  - Global tasks must have `key` and `params`\n  - Circular dependency detection\n  - Parameter type validation\n\n## Acceptance Criteria\n- Can parse valid YAML files into domain objects\n- Invalid YAML produces clear validation errors\n- Unit tests cover all validation scenarios\n\n## Labels\ncore, priority:high, phase:foundation",
    "labels": ["core", "priority:high", "phase:foundation"],
    "status": "complete"
  },
  {
    "title": "Core: JEXL Expression Evaluator",
    "body": "## Overview\nImplement JEXL expression evaluation with built-in functions and context.\n\n## Tasks\n- [ ] Setup Apache Commons JEXL 3\n- [ ] Create `ExpressionEvaluator` service\n- [ ] Implement `Context` record with params, env, tasks\n- [ ] Add built-in date functions: `date.today()`, `date.now()`, `date.add()`, `date.sub()`, `date.format()`\n- [ ] Add built-in string functions: `string.uuid()`, `string.slugify()`\n- [ ] Add string methods: `toUpperCase()`, `toLowerCase()`, `replace()`, `trim()`\n- [ ] Expose Math functions\n- [ ] Add support for task result references: `${task.taskname.result.property}`\n- [ ] Implement null-safe access and elvis operator\n\n## Acceptance Criteria\n- All examples from design doc evaluate correctly\n- Expression errors produce clear messages with context\n- Unit tests cover all built-in functions\n- Performance test: 10,000 evaluations < 100ms\n\n## Labels\ncore, priority:high, phase:foundation",
    "labels": ["core", "priority:high", "phase:foundation"],
    "status": "in progress"
  },
  {
    "title": "Core: Graph and Task Loader with Hot Reload",
    "body": "## Overview\nImplement loading of YAML configurations from filesystem with hot reload in dev mode.\n\n## Tasks\n- [ ] Create `GraphLoader` service\n- [ ] Implement loading from `orchestrator.config.graphs` directory\n- [ ] Implement loading from `orchestrator.config.tasks` directory\n- [ ] Store definitions in Hazelcast maps: `graph-definitions`, `task-definitions`\n- [ ] Create `ConfigWatcher` for dev mode (using WatchService)\n- [ ] Implement hot reload on file changes\n- [ ] Add validation on load with clear error reporting\n- [ ] Log loaded graphs and tasks on startup\n\n## Acceptance Criteria\n- All YAML files loaded on startup\n- Invalid files produce clear errors without stopping startup\n- In dev mode, file changes trigger reload within 1 second\n- Logs show which files were loaded/reloaded\n\n## Labels\ncore, priority:high, phase:foundation",
    "labels": ["core", "priority:high", "phase:foundation"]
  },
  {
    "title": "Core: Hazelcast Configuration and State Management",
    "body": "## Overview\nSetup Hazelcast for distributed state management with embedded and cluster modes.\n\n## Tasks\n- [ ] Configure embedded Hazelcast for dev mode\n- [ ] Configure clustered Hazelcast for prod mode\n- [ ] Create IMaps:\n  - `graph-definitions`\n  - `task-definitions`\n  - `graph-executions`\n  - `task-executions`\n  - `global-tasks`\n  - `workers`\n- [ ] Create IQueue: `work-queue`\n- [ ] Implement serialization for all domain objects\n- [ ] Add Hazelcast health check\n- [ ] Configure cluster discovery for Kubernetes\n\n## Acceptance Criteria\n- Embedded mode works in dev\n- Cluster mode connects to external Hazelcast\n- All maps and queues accessible\n- Health check reports Hazelcast status\n\n## Labels\ncore, priority:high, phase:foundation",
    "labels": ["core", "priority:high", "phase:foundation"]
  },
  {
    "title": "Core: JGraphT DAG Builder and Evaluator",
    "body": "## Overview\nImplement DAG construction and evaluation using JGraphT.\n\n## Tasks\n- [ ] Add JGraphT dependency\n- [ ] Create `JGraphTService`\n- [ ] Implement `buildDAG()` to create DirectedAcyclicGraph from Graph definition\n- [ ] Add cycle detection with clear error messages\n- [ ] Implement `findReadyTasks()` to identify tasks with satisfied dependencies\n- [ ] Implement topological sort for execution order\n- [ ] Add support for task references in depends_on\n- [ ] Handle both inline tasks and global task references\n\n## Acceptance Criteria\n- DAG correctly represents graph structure\n- Cycle detection prevents invalid graphs\n- `findReadyTasks()` correctly identifies executable tasks\n- Unit tests cover various graph topologies\n\n## Labels\ncore, priority:high, phase:foundation",
    "labels": ["core", "priority:high", "phase:foundation"]
  },
  {
    "title": "Core: Domain Model - Executions and State",
    "body": "## Overview\nDefine domain models for execution state and lifecycle.\n\n## Tasks\n- [ ] Create `GraphExecution` record:\n  - id, graphName, params, status, triggeredBy, startedAt, completedAt, error\n- [ ] Create `TaskExecution` record:\n  - id, graphExecutionId, taskName, status, workerId, threadName, startedAt, completedAt, duration, result, error, attempt\n- [ ] Create `GlobalTaskExecution` record:\n  - id, taskName, resolvedKey, params, status, linkedGraphExecutions, startedAt, completedAt, result\n- [ ] Create `Worker` record:\n  - id, threads, activeThreads, lastHeartbeat, status\n- [ ] Define enums: `GraphStatus`, `TaskStatus`, `WorkerStatus`\n- [ ] Implement state transition validation\n\n## Acceptance Criteria\n- All records properly serializable\n- State transitions validated\n- Status enums cover all states from design\n\n## Labels\ncore, priority:high, phase:foundation",
    "labels": ["core", "priority:high", "phase:foundation"],
    "status": "complete"
  },
  {
    "title": "Core: Graph Evaluator - Execution Engine",
    "body": "## Overview\nImplement the core graph evaluation engine that schedules tasks based on dependencies.\n\n## Tasks\n- [ ] Create `GraphEvaluator` service\n- [ ] Implement `evaluate()` method:\n  - Build DAG\n  - Get current execution state\n  - Find ready tasks\n  - Schedule tasks (regular or global)\n  - Update graph status\n- [ ] Handle task completion events\n- [ ] Handle task failure events\n- [ ] Implement graph status updates (RUNNING, COMPLETED, FAILED, STALLED)\n- [ ] Support re-evaluation on task state changes\n- [ ] Publish events to Vert.x EventBus\n\n## Acceptance Criteria\n- Graph executes tasks in correct dependency order\n- Parallel tasks execute concurrently\n- Failed tasks mark graph as FAILED\n- Graph completes when all tasks complete\n- Events published for all state changes\n\n## Labels\ncore, priority:critical, phase:core",
    "labels": ["core", "priority:critical", "phase:core"]
  },
  {
    "title": "Core: Global Task Deduplication",
    "body": "## Overview\nImplement global task deduplication so multiple graphs can share task executions.\n\n## Tasks\n- [ ] Create `TaskExecutionKey` record (taskName, resolvedKey)\n- [ ] Implement global task key resolution with expression evaluation\n- [ ] Implement `scheduleGlobalTask()` in GraphEvaluator:\n  - Check for existing execution\n  - Link to existing or create new\n  - Add graph to linkedGraphExecutions\n- [ ] Implement global task completion notification to all linked graphs\n- [ ] Handle global task failure propagation\n- [ ] Add logging for global task deduplication\n\n## Acceptance Criteria\n- Multiple graphs with same global task key share execution\n- All linked graphs notified on completion\n- Failed global task notifies all linked graphs\n- Unit tests verify deduplication logic\n\n## Labels\ncore, priority:critical, phase:core",
    "labels": ["core", "priority:critical", "phase:core"]
  },
  {
    "title": "Core: Parameter Resolution and Scoping",
    "body": "## Overview\nImplement parameter resolution with proper scoping hierarchy.\n\n## Tasks\n- [ ] Create `ParameterResolver` service\n- [ ] Implement resolution hierarchy:\n  1. Runtime invocation params\n  2. Graph task reference params\n  3. Global task default params\n  4. Graph default params\n- [ ] Validate required parameters\n- [ ] Type coercion for parameters\n- [ ] Expression evaluation in parameter defaults\n- [ ] Clear error messages for missing required params\n\n## Acceptance Criteria\n- Parameters resolve in correct priority order\n- Runtime params override all others\n- Missing required params produce clear errors\n- Unit tests cover all scoping scenarios\n\n## Labels\ncore, priority:high, phase:core",
    "labels": ["core", "priority:high", "phase:core"]
  },
  {
    "title": "Worker: Task Executor - Command Execution",
    "body": "## Overview\nImplement task execution with process management, timeout, and output capture.\n\n## Tasks\n- [ ] Create `TaskExecutor` service\n- [ ] Implement `execute()` method:\n  - Evaluate all expressions in command, args, env\n  - Build ProcessBuilder\n  - Set environment variables\n  - Redirect stderr to stdout\n  - Execute with timeout\n  - Capture output\n  - Parse JSON result if present\n- [ ] Implement trial run mode (log without executing)\n- [ ] Handle process timeout with force kill\n- [ ] Capture exit codes\n- [ ] Return `TaskResult` with success/failure and data\n\n## Acceptance Criteria\n- Commands execute successfully\n- Timeouts enforced and processes killed\n- Output captured and logged\n- JSON output parsed for downstream tasks\n- Trial run mode works correctly\n- Exit codes properly handled\n\n## Labels\nworker, priority:critical, phase:core",
    "labels": ["worker", "priority:critical", "phase:core"]
  },
  {
    "title": "Worker: Worker Pool - Multi-threaded Execution",
    "body": "## Overview\nImplement multi-threaded worker pool for task execution.\n\n## Tasks\n- [ ] Create `WorkerPool` service\n- [ ] Implement `start()` method:\n  - Create ExecutorService with configurable threads\n  - Start worker threads\n  - Start heartbeat\n- [ ] Implement `workerLoop()`:\n  - Poll work queue with timeout\n  - Execute tasks via TaskExecutor\n  - Log task events\n  - Handle exceptions\n- [ ] Implement heartbeat mechanism (every 10s)\n- [ ] Register worker in Hazelcast on startup\n- [ ] Implement graceful shutdown\n- [ ] Thread naming for observability\n\n## Acceptance Criteria\n- Worker pool starts with configured threads\n- Tasks pulled from queue and executed\n- Heartbeats sent regularly\n- Graceful shutdown waits for tasks to complete\n- Thread names include worker ID\n\n## Labels\nworker, priority:critical, phase:core",
    "labels": ["worker", "priority:critical", "phase:core"]
  },
  {
    "title": "Worker: Work Message and Queue",
    "body": "## Overview\nImplement work message structure and queue publishing.\n\n## Tasks\n- [ ] Create `WorkMessage` record:\n  - executionId, taskName, command, args, env, timeoutSeconds, attempt, context\n- [ ] Create `WorkQueue` service for publishing\n- [ ] Implement retry logic for failed tasks\n- [ ] Add exponential backoff for retries\n- [ ] Implement max retry configuration\n- [ ] Log work queue metrics\n\n## Acceptance Criteria\n- Work messages published to Hazelcast queue\n- Failed tasks retry with backoff\n- Max retries enforced\n- Queue metrics available\n\n## Labels\nworker, priority:high, phase:core",
    "labels": ["worker", "priority:high", "phase:core"]
  },
  {
    "title": "Storage: Event Store - JSONL File Backend",
    "body": "## Overview\nImplement event logging to JSONL files with local and cloud storage support.\n\n## Tasks\n- [ ] Create `Event` record with all event types\n- [ ] Create `EventStore` service\n- [ ] Implement `append()` method:\n  - Write to date-partitioned files (YYYY-MM-DD.jsonl)\n  - JSON serialize events\n- [ ] Implement `readSince()` method:\n  - Read from multiple date files\n  - Filter by timestamp\n  - Stream events\n- [ ] Implement `findLastEvent()` for recovery\n- [ ] Define all event types:\n  - GRAPH_STARTED, GRAPH_COMPLETED, GRAPH_FAILED\n  - TASK_QUEUED, TASK_STARTED, TASK_COMPLETED, TASK_FAILED\n  - GLOBAL_TASK_STARTED, GLOBAL_TASK_LINKED, GLOBAL_TASK_COMPLETED\n  - WORKER_HEARTBEAT, WORKER_DIED\n  - CLUSTER_RESTART, CLUSTER_RESET\n\n## Acceptance Criteria\n- Events written to daily files\n- Events readable by date range\n- JSON format is valid and parseable\n- All event types properly serialized\n\n## Labels\nstorage, priority:high, phase:core",
    "labels": ["storage", "priority:high", "phase:core"]
  },
  {
    "title": "Storage: Storage Adapter - Multi-backend Support",
    "body": "## Overview\nImplement storage adapters for local filesystem, GCS, and S3.\n\n## Tasks\n- [ ] Create `StorageAdapter` interface:\n  - `append(path, content)`\n  - `readLines(path)`\n- [ ] Implement `LocalFilesystemAdapter`\n- [ ] Implement `GcsStorageAdapter` (using Google Cloud Storage client)\n- [ ] Implement `S3StorageAdapter` (using AWS SDK)\n- [ ] Create `StorageAdapterFactory` to select adapter by path prefix\n- [ ] Handle create directory for local\n- [ ] Handle blob operations for cloud storage\n- [ ] Add proper error handling\n\n## Acceptance Criteria\n- Local filesystem storage works\n- GCS storage works with proper authentication\n- S3 storage works with proper authentication\n- Factory selects correct adapter by path\n- Error handling provides clear messages\n\n## Labels\nstorage, priority:high, phase:core",
    "labels": ["storage", "priority:high", "phase:core"]
  },
  {
    "title": "Storage: State Recovery on Startup",
    "body": "## Overview\nImplement state recovery from event log on orchestrator startup.\n\n## Tasks\n- [ ] Create `StateRecoveryService`\n- [ ] Implement `onStart()` method:\n  - Find recovery point (last CLUSTER_RESET or 24h ago)\n  - Read events since recovery point\n  - Replay events to rebuild state\n  - Clean up stale executions\n- [ ] Implement event replay logic for each event type\n- [ ] Handle partial state recovery\n- [ ] Log recovery progress\n- [ ] Mark recovered executions as STALLED if incomplete\n\n## Acceptance Criteria\n- State recovered on startup from events\n- CLUSTER_RESET event resets recovery point\n- Incomplete executions marked as STALLED\n- Recovery completes in < 10s for 1000 events\n\n## Labels\nstorage, priority:high, phase:core",
    "labels": ["storage", "priority:high", "phase:core"]
  },
  {
    "title": "Web: Base UI Layout with Tabler CSS",
    "body": "## Overview\nSetup base UI layout using Tabler.io CSS framework with Qute templates.\n\n## Tasks\n- [ ] Add Tabler CSS and JS to project (via CDN or local)\n- [ ] Create base template: `base.html` with:\n  - Header with app name\n  - Sidebar navigation\n  - Main content area\n  - Footer\n- [ ] Add Tabler Icons\n- [ ] Create navigation menu:\n  - Dashboard\n  - Graphs\n  - Tasks\n  - Workers\n  - Events\n  - Settings (dev only)\n  - Editor (dev only)\n- [ ] Setup responsive design\n- [ ] Add dark mode support\n\n## Acceptance Criteria\n- Professional looking UI\n- Responsive on mobile and desktop\n- Navigation works\n- Consistent styling across pages\n\n## Labels\nui, priority:high, phase:ui",
    "labels": ["ui", "priority:high", "phase:ui"]
  },
  {
    "title": "Web: Dashboard Page",
    "body": "## Overview\nCreate dashboard page with system overview and metrics.\n\n## Tasks\n- [ ] Create `DashboardController` and template\n- [ ] Add stats cards:\n  - Active graphs\n  - Queued tasks\n  - Active workers\n  - Success rate (24h)\n- [ ] Add recent executions table (last 10)\n- [ ] Add active graphs list with status\n- [ ] Add system health indicators\n- [ ] Auto-refresh every 5 seconds\n\n## Acceptance Criteria\n- Dashboard shows real-time data\n- Stats cards update automatically\n- Recent executions visible\n- Links to detailed views work\n\n## Labels\nui, priority:high, phase:ui",
    "labels": ["ui", "priority:high", "phase:ui"]
  },
  {
    "title": "Web: Graphs List Page",
    "body": "## Overview\nCreate graphs list page with search and filtering.\n\n## Tasks\n- [ ] Create `GraphsController` and template\n- [ ] Display table of all graphs:\n  - Name\n  - Description\n  - Last run (timestamp)\n  - Status\n  - Actions (Execute, View, History)\n- [ ] Add search/filter functionality\n- [ ] Add \"Execute\" button that opens param form modal\n- [ ] Add param form with all graph parameters\n- [ ] Trigger execution on form submit\n\n## Acceptance Criteria\n- All graphs displayed\n- Search/filter works\n- Execute button opens param form\n- Execution triggered with params\n- Redirect to graph detail on execute\n\n## Labels\nui, priority:high, phase:ui",
    "labels": ["ui", "priority:high", "phase:ui"]
  },
  {
    "title": "Web: Graph Detail Page - Real-time Execution View",
    "body": "## Overview\nCreate graph detail page with real-time execution monitoring.\n\n## Tasks\n- [ ] Create `GraphDetailController` and template\n- [ ] Implement tabs:\n  - Topology (DAG visualization)\n  - Tasks (table view)\n  - Gantt (timeline view)\n  - Logs (aggregated logs)\n- [ ] Topology tab:\n  - Use dagre-d3 for DAG visualization\n  - Color-code nodes by status\n  - Show task names and status\n- [ ] Tasks tab:\n  - Table with all tasks\n  - Columns: Name, Status, Duration, Worker, Actions\n  - Link to task logs\n- [ ] Gantt tab:\n  - Use vis-timeline\n  - Show task execution timeline\n  - Show task dependencies\n- [ ] Logs tab:\n  - Stream logs from all tasks\n  - Filter by task\n  - Auto-scroll\n- [ ] Add action buttons:\n  - Execute (with params)\n  - Pause/Resume\n  - View History\n- [ ] Real-time updates via SSE\n\n## Acceptance Criteria\n- DAG visualization shows graph structure\n- Real-time status updates work\n- Gantt chart shows execution timeline\n- Logs stream in real-time\n- All actions functional\n\n## Labels\nui, priority:critical, phase:ui",
    "labels": ["ui", "priority:critical", "phase:ui"]
  },
  {
    "title": "Web: Graph History Page",
    "body": "## Overview\nCreate page to view past graph executions.\n\n## Tasks\n- [ ] Create `GraphHistoryController` and template\n- [ ] Display table of past executions:\n  - Execution ID\n  - Started at\n  - Duration\n  - Status\n  - Triggered by\n  - Params\n- [ ] Add filters:\n  - Date range\n  - Status\n  - Triggered by\n- [ ] Add pagination\n- [ ] Link to specific execution detail\n- [ ] Show execution statistics\n\n## Acceptance Criteria\n- Past executions displayed\n- Filters work correctly\n- Pagination works\n- Links to detail page work\n\n## Labels\nui, priority:medium, phase:ui",
    "labels": ["ui", "priority:medium", "phase:ui"]
  },
  {
    "title": "Web: Global Tasks Page",
    "body": "## Overview\nCreate page to view global tasks and their executions.\n\n## Tasks\n- [ ] Create `TasksController` and template\n- [ ] Display table of global tasks:\n  - Name\n  - Active executions\n  - Linked graphs\n  - Recent completions\n- [ ] Show current global task executions\n- [ ] Show which graphs are using each task\n- [ ] Add execution history for each task\n- [ ] Link to graph executions\n\n## Acceptance Criteria\n- All global tasks displayed\n- Active executions visible\n- Linked graphs shown\n- Links to graphs work\n\n## Labels\nui, priority:medium, phase:ui",
    "labels": ["ui", "priority:medium", "phase:ui"]
  },
  {
    "title": "Web: Workers Page",
    "body": "## Overview\nCreate page to monitor worker health and utilization.\n\n## Tasks\n- [ ] Create `WorkersController` and template\n- [ ] Display table of workers:\n  - Worker ID\n  - Status (healthy/dead)\n  - Threads (active/total)\n  - Active tasks\n  - Last heartbeat\n  - Uptime\n- [ ] Show worker metrics if available\n- [ ] Add status indicators (green/red)\n- [ ] Show current tasks being executed\n- [ ] Auto-refresh every 5 seconds\n\n## Acceptance Criteria\n- All workers displayed\n- Status accurately reflects health\n- Active tasks shown\n- Auto-refresh works\n\n## Labels\nui, priority:medium, phase:ui",
    "labels": ["ui", "priority:medium", "phase:ui"]
  },
  {
    "title": "Web: Events Page",
    "body": "## Overview\nCreate page to view and search event log.\n\n## Tasks\n- [ ] Create `EventsController` and template\n- [ ] Display event stream:\n  - Timestamp\n  - Event type\n  - Details\n- [ ] Add search functionality:\n  - By event type\n  - By graph execution ID\n  - By task execution ID\n  - By date range\n- [ ] Add event type filter dropdown\n- [ ] Implement pagination\n- [ ] Add \"Download as JSONL\" button\n- [ ] Real-time events via SSE\n\n## Acceptance Criteria\n- Events displayed in reverse chronological order\n- Search/filter works\n- Download produces valid JSONL\n- Real-time events stream in\n\n## Labels\nui, priority:medium, phase:ui",
    "labels": ["ui", "priority:medium", "phase:ui"]
  },
  {
    "title": "Web: Editor Page (Dev Mode Only)",
    "body": "## Overview\nCreate web-based YAML editor for graphs and tasks.\n\n## Tasks\n- [ ] Create `EditorController` and template\n- [ ] Add Monaco Editor (VS Code editor)\n- [ ] Create file tree:\n  - Graphs folder\n  - Tasks folder\n- [ ] Implement file operations:\n  - Load file\n  - Save file\n  - Validate YAML\n- [ ] Add syntax highlighting for YAML\n- [ ] Show validation errors in editor\n- [ ] Trigger hot reload on save\n- [ ] Only accessible in dev mode\n- [ ] Add security to prevent directory traversal\n\n## Acceptance Criteria\n- Editor loads and displays files\n- YAML syntax highlighting works\n- Save writes to filesystem\n- Validation shows errors\n- Only accessible in dev mode\n- Cannot access files outside config directories\n\n## Labels\nui, priority:medium, phase:ui, dev-mode",
    "labels": ["ui", "priority:medium", "phase:ui", "dev-mode"]
  },
  {
    "title": "Web: Settings Page",
    "body": "## Overview\nCreate settings page with system configuration and admin actions.\n\n## Tasks\n- [ ] Create `SettingsController` and template\n- [ ] Display system configuration (read-only)\n- [ ] Add nuclear options:\n  - Restart orchestrator\n  - Hard reset (clear all state)\n  - Clear event log\n- [ ] Show system info:\n  - Version\n  - Mode (dev/prod)\n  - Uptime\n  - Hazelcast cluster status\n- [ ] Add confirmation dialogs for dangerous actions\n- [ ] Log all admin actions to events\n\n## Acceptance Criteria\n- Configuration displayed\n- Admin actions work\n- Confirmation required for dangerous actions\n- Actions logged to events\n\n## Labels\nui, priority:medium, phase:ui",
    "labels": ["ui", "priority:medium", "phase:ui"]
  },
  {
    "title": "Web: Server-Sent Events (SSE) for Real-time Updates",
    "body": "## Overview\nImplement SSE endpoints for real-time UI updates.\n\n## Tasks\n- [ ] Create `StreamController`\n- [ ] Implement SSE endpoint for graph execution: `/api/stream/graphs/{id}`\n- [ ] Implement SSE endpoint for dashboard: `/api/stream/dashboard`\n- [ ] Implement SSE endpoint for events: `/api/stream/events`\n- [ ] Use Vert.x EventBus to bridge internal events to SSE\n- [ ] Handle client disconnection cleanup\n- [ ] Add event types:\n  - task-status\n  - graph-status\n  - worker-heartbeat\n  - new-event\n\n## Acceptance Criteria\n- SSE connections established successfully\n- Events streamed to clients in real-time\n- Client disconnection handled gracefully\n- No memory leaks from abandoned connections\n\n## Labels\nui, api, priority:high, phase:ui",
    "labels": ["ui", "api", "priority:high", "phase:ui"]
  },
  {
    "title": "API: REST Endpoints - Graph Operations",
    "body": "## Overview\nImplement REST API endpoints for graph operations.\n\n## Tasks\n- [ ] Create `GraphApiController`\n- [ ] Implement endpoints:\n  - `GET /api/graphs` - List all graphs\n  - `GET /api/graphs/{name}` - Get graph definition\n  - `POST /api/graphs/{name}/execute` - Execute graph with params\n  - `GET /api/graphs/executions/{id}` - Get execution status\n  - `POST /api/graphs/executions/{id}/pause` - Pause execution\n  - `POST /api/graphs/executions/{id}/resume` - Resume execution\n  - `GET /api/graphs/{name}/history` - Get execution history\n- [ ] Add request/response DTOs\n- [ ] Add validation\n- [ ] Add error handling with proper HTTP status codes\n- [ ] Document with OpenAPI annotations\n\n## Acceptance Criteria\n- All endpoints functional\n- Validation works correctly\n- Error responses are clear\n- OpenAPI documentation generated\n\n## Labels\napi, priority:high, phase:api",
    "labels": ["api", "priority:high", "phase:api"]
  },
  {
    "title": "API: REST Endpoints - Task Operations",
    "body": "## Overview\nImplement REST API endpoints for task operations.\n\n## Tasks\n- [ ] Create `TaskApiController`\n- [ ] Implement endpoints:\n  - `GET /api/tasks` - List all tasks\n  - `GET /api/tasks/{name}` - Get task definition\n  - `GET /api/tasks/executions/{id}` - Get task execution status\n  - `GET /api/tasks/executions/{id}/logs` - Get task logs\n  - `GET /api/tasks/global` - List global tasks\n  - `GET /api/tasks/global/{name}/executions` - Get global task executions\n- [ ] Add request/response DTOs\n- [ ] Add error handling\n- [ ] Document with OpenAPI\n\n## Acceptance Criteria\n- All endpoints functional\n- Task logs accessible\n- Global task info available\n- Documentation complete\n\n## Labels\napi, priority:high, phase:api",
    "labels": ["api", "priority:high", "phase:api"]
  },
  {
    "title": "API: REST Endpoints - Worker Operations",
    "body": "## Overview\nImplement REST API endpoints for worker operations.\n\n## Tasks\n- [ ] Create `WorkerApiController`\n- [ ] Implement endpoints:\n  - `GET /api/workers` - List all workers\n  - `GET /api/workers/{id}` - Get worker details\n  - `GET /api/workers/{id}/tasks` - Get active tasks\n- [ ] Add worker metrics if available\n- [ ] Add error handling\n- [ ] Document with OpenAPI\n\n## Acceptance Criteria\n- All endpoints functional\n- Worker status accurate\n- Active tasks visible\n- Documentation complete\n\n## Labels\napi, priority:medium, phase:api",
    "labels": ["api", "priority:medium", "phase:api"]
  },
  {
    "title": "API: REST Endpoints - Event Operations",
    "body": "## Overview\nImplement REST API endpoints for event log operations.\n\n## Tasks\n- [ ] Create `EventApiController`\n- [ ] Implement endpoints:\n  - `GET /api/events` - List events with filters\n  - `GET /api/events/download` - Download events as JSONL\n  - `GET /api/events/search` - Search events\n- [ ] Add filtering:\n  - By event type\n  - By date range\n  - By graph/task execution ID\n- [ ] Add pagination\n- [ ] Add error handling\n- [ ] Document with OpenAPI\n\n## Acceptance Criteria\n- Events queryable via API\n- Filters work correctly\n- Download produces valid JSONL\n- Pagination works\n\n## Labels\napi, priority:medium, phase:api",
    "labels": ["api", "priority:medium", "phase:api"]
  },
  {
    "title": "Scheduling: Cron Scheduler Integration",
    "body": "## Overview\nImplement cron-based scheduling for graphs using Quarkus Quartz.\n\n## Tasks\n- [ ] Create `SchedulerService` using Quartz\n- [ ] Parse cron expressions from graph definitions\n- [ ] Register scheduled jobs on graph load\n- [ ] Trigger graph executions on schedule\n- [ ] Unregister jobs when graphs removed/changed\n- [ ] Handle timezone configuration\n- [ ] Log scheduled executions\n- [ ] Add schedule info to graph detail page\n\n## Acceptance Criteria\n- Graphs with schedule execute on time\n- Cron expressions validated on load\n- Schedule changes take effect on reload\n- Scheduled executions logged\n\n## Labels\nscheduling, priority:high, phase:features",
    "labels": ["scheduling", "priority:high", "phase:features"]
  },
  {
    "title": "Triggers: Webhook Trigger Support",
    "body": "## Overview\nImplement webhook trigger support for graphs.\n\n## Tasks\n- [ ] Create `TriggerController`\n- [ ] Implement webhook endpoint: `POST /api/triggers/webhook/{graphName}`\n- [ ] Support webhook authentication (optional token)\n- [ ] Extract params from webhook body\n- [ ] Trigger graph execution with params\n- [ ] Return execution ID in response\n- [ ] Log webhook triggers\n- [ ] Add webhook URL to graph detail page\n\n## Acceptance Criteria\n- Webhook triggers graph execution\n- Params extracted from body\n- Authentication works if configured\n- Execution ID returned\n- Triggers logged\n\n## Labels\ntriggers, priority:medium, phase:features",
    "labels": ["triggers", "priority:medium", "phase:features"]
  },
  {
    "title": "Triggers: Google Pub/Sub Trigger Support",
    "body": "## Overview\nImplement Google Pub/Sub trigger support for graphs.\n\n## Tasks\n- [ ] Setup Google Pub/Sub client\n- [ ] Create `PubSubTriggerService`\n- [ ] Subscribe to configured topics\n- [ ] Parse message data as params\n- [ ] Trigger graph execution\n- [ ] Acknowledge messages on successful trigger\n- [ ] Handle subscription configuration in graph YAML\n- [ ] Log Pub/Sub triggers\n\n## Acceptance Criteria\n- Pub/Sub messages trigger graphs\n- Message data used as params\n- Messages acknowledged properly\n- Configuration works via YAML\n\n## Labels\ntriggers, priority:medium, phase:features",
    "labels": ["triggers", "priority:medium", "phase:features"]
  },
  {
    "title": "Monitoring: Prometheus Metrics",
    "body": "## Overview\nImplement Prometheus metrics for observability.\n\n## Tasks\n- [ ] Add Micrometer metrics\n- [ ] Expose metrics at `/q/metrics`\n- [ ] Add custom metrics:\n  - `graphs_total` - Total graphs loaded\n  - `graph_executions_total{status}` - Executions by status\n  - `graph_execution_duration_seconds` - Execution duration histogram\n  - `tasks_queued` - Tasks in queue\n  - `tasks_executing` - Tasks currently executing\n  - `tasks_total{status}` - Tasks by status\n  - `workers_active` - Active workers\n  - `worker_threads_active` - Active worker threads\n  - `global_tasks_active` - Active global task executions\n- [ ] Add JVM metrics\n- [ ] Add Hazelcast metrics\n- [ ] Document metrics in README\n\n## Acceptance Criteria\n- Metrics exposed at /q/metrics\n- Custom metrics tracked correctly\n- Prometheus can scrape metrics\n- Documentation complete\n\n## Labels\nmonitoring, priority:high, phase:features",
    "labels": ["monitoring", "priority:high", "phase:features"]
  },
  {
    "title": "Monitoring: Structured Logging",
    "body": "## Overview\nImplement structured JSON logging for production.\n\n## Tasks\n- [ ] Configure JSON logging for prod profile\n- [ ] Add structured fields to logs:\n  - graphExecutionId\n  - taskExecutionId\n  - workerId\n  - graphName\n  - taskName\n- [ ] Use MDC for context propagation\n- [ ] Add correlation IDs\n- [ ] Configure log levels per package\n- [ ] Add log sampling for high-volume events\n\n## Acceptance Criteria\n- JSON logs in prod mode\n- Text logs in dev mode\n- Structured fields present\n- Correlation IDs work\n- Log levels configurable\n\n## Labels\nmonitoring, priority:high, phase:features",
    "labels": ["monitoring", "priority:high", "phase:features"]
  },
  {
    "title": "Monitoring: OpenTelemetry Tracing",
    "body": "## Overview\nImplement distributed tracing with OpenTelemetry.\n\n## Tasks\n- [ ] Configure OpenTelemetry\n- [ ] Add spans for:\n  - Graph execution\n  - Task execution\n  - Expression evaluation\n  - Event logging\n- [ ] Add span attributes\n- [ ] Configure trace sampling\n- [ ] Export to configured backend (Jaeger/Zipkin/Cloud Trace)\n- [ ] Add trace IDs to logs\n\n## Acceptance Criteria\n- Traces collected and exported\n- Spans show execution flow\n- Trace IDs in logs\n- Sampling configured\n\n## Labels\nmonitoring, priority:medium, phase:features",
    "labels": ["monitoring", "priority:medium", "phase:features"]
  },
  {
    "title": "Dev Mode: Trial Run Mode",
    "body": "## Overview\nImplement trial run mode that logs commands without executing them.\n\n## Tasks\n- [ ] Add `orchestrator.dev.trial-run` config option\n- [ ] Modify `TaskExecutor` to check trial run flag\n- [ ] Log command details without executing:\n  - Full command\n  - Working directory\n  - Environment\n  - Timeout\n- [ ] Return fake success result\n- [ ] Add visual indicators in UI for trial run mode\n- [ ] Document trial run mode in README\n\n## Acceptance Criteria\n- Commands logged but not executed in trial run mode\n- Graphs complete successfully in trial run\n- UI shows trial run indicator\n- Easy to enable/disable\n\n## Labels\ndev-mode, priority:high, phase:features",
    "labels": ["dev-mode", "priority:high", "phase:features"]
  },
  {
    "title": "Testing: Unit Tests - Core Components",
    "body": "## Overview\nWrite comprehensive unit tests for core components.\n\n## Tasks\n- [ ] Test `ExpressionEvaluator` with all functions\n- [ ] Test `ParameterResolver` with scoping\n- [ ] Test `JGraphTService` with various DAGs\n- [ ] Test `GraphEvaluator` state transitions\n- [ ] Test YAML parser and validator\n- [ ] Test global task deduplication logic\n- [ ] Achieve >80% code coverage for core\n\n## Acceptance Criteria\n- All core components have unit tests\n- Tests cover happy path and error cases\n- Code coverage >80%\n- Tests run in <10 seconds\n\n## Labels\ntesting, priority:high, phase:testing",
    "labels": ["testing", "priority:high", "phase:testing"]
  },
  {
    "title": "Testing: Integration Tests - Full Graph Execution",
    "body": "## Overview\nWrite integration tests for full graph execution flows.\n\n## Tasks\n- [ ] Setup test profile with embedded Hazelcast\n- [ ] Create test graphs and tasks\n- [ ] Test simple linear graph execution\n- [ ] Test parallel task execution\n- [ ] Test global task deduplication\n- [ ] Test task failure and retry\n- [ ] Test graph failure scenarios\n- [ ] Test parameter resolution\n- [ ] Use Testcontainers if needed\n\n## Acceptance Criteria\n- Integration tests cover main execution flows\n- Tests use real Hazelcast\n- Tests run in <30 seconds\n- All scenarios pass reliably\n\n## Labels\ntesting, priority:high, phase:testing",
    "labels": ["testing", "priority:high", "phase:testing"]
  },
  {
    "title": "Testing: E2E Tests - API and UI",
    "body": "## Overview\nWrite end-to-end tests for API and UI.\n\n## Tasks\n- [ ] Setup E2E test profile\n- [ ] Test graph execution via API\n- [ ] Test webhook triggers\n- [ ] Test parameter passing\n- [ ] Test event logging\n- [ ] Test SSE connections\n- [ ] Test UI navigation\n- [ ] Use REST Assured for API tests\n\n## Acceptance Criteria\n- E2E tests cover critical user flows\n- Tests run against running application\n- Tests reliable and repeatable\n- Documentation for running E2E tests\n\n## Labels\ntesting, priority:medium, phase:testing",
    "labels": ["testing", "priority:medium", "phase:testing"]
  },
  {
    "title": "Deployment: Docker Images",
    "body": "## Overview\nCreate production-ready Docker images.\n\n## Tasks\n- [ ] Update Dockerfile.jvm for production\n- [ ] Add multi-stage build for smaller images\n- [ ] Configure non-root user\n- [ ] Add health check\n- [ ] Optimize layer caching\n- [ ] Test images locally\n- [ ] Document image usage\n- [ ] Setup automated builds\n\n## Acceptance Criteria\n- Docker image builds successfully\n- Image runs with non-root user\n- Health check works\n- Image size optimized\n- Documentation complete\n\n## Labels\ndeployment, priority:high, phase:deployment",
    "labels": ["deployment", "priority:high", "phase:deployment"]
  },
  {
    "title": "Deployment: Kubernetes Manifests",
    "body": "## Overview\nCreate Kubernetes manifests for GKE deployment.\n\n## Tasks\n- [ ] Create namespace: `orchestrator`\n- [ ] Create Hazelcast StatefulSet\n- [ ] Create Hazelcast headless Service\n- [ ] Create Orchestrator Deployment\n- [ ] Create Orchestrator Service (LoadBalancer)\n- [ ] Create Worker Deployment\n- [ ] Create Worker HorizontalPodAutoscaler\n- [ ] Create ConfigMap for graphs/tasks\n- [ ] Create ServiceAccount and RBAC\n- [ ] Add pod anti-affinity for Hazelcast\n- [ ] Configure resource limits\n- [ ] Add liveness/readiness probes\n- [ ] Document deployment process\n\n## Acceptance Criteria\n- Manifests deploy successfully to GKE\n- Hazelcast cluster forms correctly\n- Orchestrator and workers connect\n- HPA scales workers\n- Documentation complete\n\n## Labels\ndeployment, kubernetes, priority:high, phase:deployment",
    "labels": ["deployment", "kubernetes", "priority:high", "phase:deployment"]
  },
  {
    "title": "Deployment: GitHub Actions CI/CD",
    "body": "## Overview\nSetup CI/CD pipeline with GitHub Actions.\n\n## Tasks\n- [ ] Create workflow: `.github/workflows/build.yml`\n  - Build on push to main\n  - Run unit tests\n  - Run integration tests\n  - Build Docker image\n  - Push to GCR\n- [ ] Create workflow: `.github/workflows/deploy-config.yml`\n  - Deploy on changes to graphs/ or tasks/\n  - Update ConfigMap\n  - Restart orchestrator\n- [ ] Create workflow: `.github/workflows/deploy-app.yml`\n  - Deploy new version to GKE\n  - Rolling update\n- [ ] Add test coverage reporting\n- [ ] Add security scanning\n- [ ] Document workflows\n\n## Acceptance Criteria\n- CI runs on every push\n- Tests pass before deploy\n- Docker images pushed to GCR\n- Config changes deployed automatically\n- Documentation complete\n\n## Labels\ndeployment, ci-cd, priority:high, phase:deployment",
    "labels": ["deployment", "ci-cd", "priority:high", "phase:deployment"]
  },
  {
    "title": "Documentation: User Guide",
    "body": "## Overview\nWrite comprehensive user guide.\n\n## Tasks\n- [ ] Write getting started guide\n- [ ] Document YAML schema:\n  - Task definition\n  - Graph definition\n  - Parameter types\n- [ ] Document JEXL expression language\n- [ ] Document built-in functions\n- [ ] Document global tasks\n- [ ] Document parameter scoping\n- [ ] Document triggers\n- [ ] Document scheduling\n- [ ] Add examples for common patterns\n- [ ] Add troubleshooting section\n\n## Acceptance Criteria\n- User can get started with documentation alone\n- All features documented\n- Examples work as written\n- Troubleshooting helpful\n\n## Labels\ndocumentation, priority:high, phase:documentation",
    "labels": ["documentation", "priority:high", "phase:documentation"]
  },
  {
    "title": "Documentation: Operator Guide",
    "body": "## Overview\nWrite operator guide for deployment and operations.\n\n## Tasks\n- [ ] Document architecture\n- [ ] Document deployment options:\n  - Local development\n  - Docker Compose\n  - GKE\n- [ ] Document configuration options\n- [ ] Document monitoring and metrics\n- [ ] Document event log management\n- [ ] Document backup and recovery\n- [ ] Document scaling guidelines\n- [ ] Document security considerations\n- [ ] Add runbook for common issues\n\n## Acceptance Criteria\n- Operators can deploy with documentation alone\n- Configuration well explained\n- Monitoring setup documented\n- Troubleshooting comprehensive\n\n## Labels\ndocumentation, priority:high, phase:documentation",
    "labels": ["documentation", "priority:high", "phase:documentation"]
  },
  {
    "title": "Documentation: API Reference",
    "body": "## Overview\nGenerate comprehensive API reference.\n\n## Tasks\n- [ ] Add OpenAPI annotations to all endpoints\n- [ ] Configure Swagger UI\n- [ ] Document request/response formats\n- [ ] Add API examples\n- [ ] Document authentication if added\n- [ ] Document rate limits if added\n- [ ] Generate API docs automatically\n- [ ] Publish API docs with application\n\n## Acceptance Criteria\n- OpenAPI spec generated\n- Swagger UI accessible\n- All endpoints documented\n- Examples work as written\n\n## Labels\ndocumentation, api, priority:medium, phase:documentation",
    "labels": ["documentation", "api", "priority:medium", "phase:documentation"]
  },
  {
    "title": "Polish: Error Handling and User Feedback",
    "body": "## Overview\nImprove error handling and user feedback throughout the application.\n\n## Tasks\n- [ ] Review all error messages for clarity\n- [ ] Add context to error messages (what was being done)\n- [ ] Implement user-friendly error pages\n- [ ] Add toast notifications for UI actions\n- [ ] Improve validation error messages\n- [ ] Add helpful hints for common mistakes\n- [ ] Log errors with full context\n- [ ] Add error recovery suggestions\n\n## Acceptance Criteria\n- Error messages clear and actionable\n- Users understand what went wrong\n- Error pages professional\n- Validation errors helpful\n\n## Labels\npolish, priority:medium, phase:polish",
    "labels": ["polish", "priority:medium", "phase:polish"]
  },
  {
    "title": "Polish: Performance Optimization",
    "body": "## Overview\nOptimize performance for better user experience.\n\n## Tasks\n- [ ] Profile expression evaluation performance\n- [ ] Optimize DAG building for large graphs\n- [ ] Add caching where appropriate\n- [ ] Optimize event log queries\n- [ ] Reduce SSE connection overhead\n- [ ] Optimize UI rendering\n- [ ] Add lazy loading for large lists\n- [ ] Benchmark critical paths\n- [ ] Add performance tests\n\n## Acceptance Criteria\n- Expression evaluation < 1ms per expression\n- DAG building < 100ms for 100-node graph\n- UI feels responsive\n- Performance regression tests in place\n\n## Labels\npolish, performance, priority:medium, phase:polish",
    "labels": ["polish", "performance", "priority:medium", "phase:polish"]
  },
  {
    "title": "Security: Authentication and Authorization",
    "body": "## Overview\nAdd authentication and authorization (if needed for production).\n\n## Tasks\n- [ ] Evaluate authentication requirements\n- [ ] Implement OIDC integration if needed\n- [ ] Add role-based access control\n- [ ] Protect API endpoints\n- [ ] Protect UI routes\n- [ ] Add audit logging for admin actions\n- [ ] Document security setup\n\n## Acceptance Criteria\n- Authentication works if enabled\n- Authorization enforced\n- Admin actions audited\n- Security documented\n\n## Labels\nsecurity, priority:medium, phase:features",
    "labels": ["security", "priority:medium", "phase:features"]
  }
]